package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/dave/jennifer/jen"
)

func main() {
	root := "."
	if len(os.Args) > 1 {
		root = os.Args[1]
	}

	if err := run(root); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}

type value struct{ token, pretty string }

func run(path string) error {
	fs := token.NewFileSet()

	pkgs, err := parser.ParseDir(fs, path, nil, parser.ParseComments)
	if err != nil {
		return err
	}

	if len(pkgs) == 0 {
		return nil
	}

	title := func(s string) string {
		return strings.ToUpper(s[:1]) + s[1:]
	}

	for _, pkg := range pkgs {
		if strings.Contains(pkg.Name, "_test") {
			continue
		}
		if len(pkg.Files) == 0 {
			continue
		}

		enums := make(map[string][]value)

		output := filepath.Join(path, fmt.Sprintf("%s_enum_gen.go", pkg.Name))

		for _, file := range pkg.Files {
			m := processFile(file)
			for k, v := range m {
				enums[k] = v
			}
		}

		if len(enums) == 0 {
			continue
		}

		f := jen.NewFile(pkg.Name)

		f.HeaderComment("Code generated by enumerator. DO NOT EDIT.")

		var enumNames []string
		for k := range enums {
			enumNames = append(enumNames, k)
		}
		sort.Strings(enumNames)

		for _, sourceName := range enumNames {
			values := enums[sourceName]
			name := title(strings.TrimSuffix(sourceName, "Enum"))

			errorMessage := fmt.Sprintf("invalid value for type '%s': '%%s'", name)

			f.Type().
				Id(name).
				Struct(jen.Id("v").Id(sourceName))

			f.Var().
				DefsFunc(func(g *jen.Group) {
					for _, v := range values {
						g.Id(title(v.token)).
							Op("=").
							Id(name).
							Values(jen.Id(v.token))
					}
				})

			f.Func().
				Params(
					jen.Id("r").Id(name),
				).
				Id("Format").
				Params(
					jen.Id("f").Qual("fmt", "State"),
					jen.Id("verb").Id("rune"),
				).
				Block(
					jen.Switch(jen.Id("verb")).BlockFunc(func(g *jen.Group) {
						hasPrettyValues := false
						for _, v := range values {
							if v.pretty != "" {
								hasPrettyValues = true
								break
							}
						}

						g.Case(jen.LitRune('s')).Block(
							jen.Id("fmt").Dot("Fprint").Call(
								jen.Id("f"), jen.Id("r").Dot("v"),
							),
						)

						g.Case(jen.LitRune('q')).Block(
							jen.Id("fmt").Dot("Fprintf").Call(
								jen.Id("f"),
								jen.Lit("%q"),
								jen.Id("r").Dot("String").Call(),
							),
						)

						if hasPrettyValues {
							g.Case(jen.LitRune('v')).Block(
								jen.Switch(jen.Id("r")).BlockFunc(func(g *jen.Group) {
									for _, v := range values {
										var val *jen.Statement
										if v.pretty == "" {
											val = jen.Id("string").Call(jen.Id("r").Dot("v"))
										} else {
											val = jen.Lit(v.pretty)
										}

										g.Case(jen.Id(title(v.token))).Block(
											jen.Id("fmt").Dot("Fprint").Call(jen.Id("f"), val),
										)
									}

									g.Default().Block(
										jen.Id("fmt").Dot("Fprint").Call(jen.Id("f"), jen.Lit("")),
									)
								}),
							)
						}

						g.Default().Block(
							jen.Id("fmt").Dot("Fprint").Call(jen.Id("f"), jen.Id("r").Dot("v")),
						)
					}),
				)

			f.Func().
				Params(
					jen.Id("r").Id(name),
				).
				Id("String").
				Params().
				String().
				Block(
					jen.Return(jen.Id("string").Call(jen.Id("r").Dot("v"))),
				)

			f.Func().
				Params(
					jen.Id("r").Id(name),
				).
				Id("MarshalText").
				Params().
				Params(
					jen.Id("[]byte"),
					jen.Id("error"),
				).
				Block(
					jen.Return(
						jen.Id("[]byte").Call(jen.Id("r").Dot("v")),
						jen.Nil(),
					),
				)

			f.Func().
				Params(
					jen.Id("r").Op("*").Id(name),
				).
				Id("UnmarshalText").
				Params(
					jen.Id("__iNpUt__").Id("[]byte"),
				).
				Params(
					jen.Id("error"),
				).
				Block(
					jen.List(
						jen.Id("s"),
						jen.Id("err"),
					).Op(":=").Id("New"+name).Call(jen.Id("string").Call(jen.Id("__iNpUt__"))),

					jen.If(jen.Id("err").Op("!=").Nil()).Block(
						jen.Return(jen.Id("err")),
					),

					jen.Id("*r").Op("=").Id("s"),

					jen.Return(
						jen.Nil(),
					),
				)

			f.Func().
				Params(
					jen.Id("r").Id(name),
				).
				Id("Value").
				Params().
				Params(
					jen.Qual("database/sql/driver", "Value"),
					jen.Id("error"),
				).
				Block(
					jen.Return(
						jen.Id("r").Dot("v"),
						jen.Nil(),
					),
				)

			f.Func().
				Params(
					jen.Id("r").Op("*").Id(name),
				).
				Id("Scan").
				Params(
					jen.Id("__iNpUt__").Any(),
				).
				Params(
					jen.Id("error"),
				).
				Block(
					jen.List(
						jen.Id("s"),
						jen.Id("err"),
					).Op(":=").Id("New"+name).Call(jen.Qual("fmt", "Sprint").Call(jen.Id("__iNpUt__"))),

					jen.If(jen.Id("err").Op("!=").Nil()).Block(
						jen.Return(jen.Id("err")),
					),

					jen.Id("*r").Op("=").Id("s"),

					jen.Return(
						jen.Nil(),
					),
				)

			f.Func().
				Id("New"+name).
				Params(jen.Id("__iNpUt__").Id("string")).
				Params(
					jen.Id(name),
					jen.Id("error"),
				).
				Block(
					jen.Switch(jen.Id("__iNpUt__")).BlockFunc(func(g *jen.Group) {
						for _, v := range values {
							g.Case(jen.Id("string").Call(jen.Id(v.token))).Block(
								jen.Return(jen.Id(title(v.token)), jen.Nil()),
							)
						}

						g.Default().Block(jen.Return(
							jen.Id(name).
								Values(),

							jen.Qual("fmt", "Errorf").Call(
								jen.Lit(errorMessage),
								jen.Id("__iNpUt__"),
							),
						))
					}),
				)
		}

		if err := f.Save(output); err != nil {
			return err
		}
	}

	return nil
}

func processFile(file *ast.File) map[string][]value {
	enumTypes := gatherEnumTypes(file)

	types := make(map[string][]value)

	for _, d := range file.Decls {
		decl, ok := d.(*ast.GenDecl)
		if !ok {
			continue
		}

		if decl.Tok != token.CONST {
			continue
		}

		if len(decl.Specs) < 2 {
			continue
		}

		for _, spec := range decl.Specs {
			v, ok := spec.(*ast.ValueSpec)
			if !ok {
				continue
			}

			ident, ok := v.Type.(*ast.Ident)
			if !ok {
				continue
			}

			name := ident.Name

			_, ok = enumTypes[name]
			if !ok {
				continue
			}

			l := types[name]

			token := v.Names[0].Name

			var pretty string
			if v.Comment != nil {
				pretty = strings.Trim(v.Comment.Text(), "\n\t")
			}

			l = append(l, value{
				token:  token,
				pretty: pretty,
			})

			types[name] = l
		}
	}

	return types
}

func gatherEnumTypes(file *ast.File) map[string]*ast.TypeSpec {
	types := make(map[string]*ast.TypeSpec)

	for _, d := range file.Decls {
		decl, ok := d.(*ast.GenDecl)
		if !ok {
			continue
		}

		if decl.Tok != token.TYPE {
			continue
		}

		spec, ok := decl.Specs[0].(*ast.TypeSpec)
		if !ok {
			continue
		}

		_, ok = spec.Type.(*ast.Ident)
		if !ok {
			continue
		}

		if !strings.HasSuffix(spec.Name.Name, "Enum") {
			continue
		}

		types[spec.Name.Name] = spec
	}

	return types
}
