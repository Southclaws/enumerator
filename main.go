//nolint:unused
package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"strings"

	"github.com/dave/jennifer/jen"
)

func main() {
	root := "."
	if len(os.Args) > 1 {
		root = os.Args[1]
	}

	if err := run(root); err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}

func run(path string) error {
	fs := token.NewFileSet()

	pkgs, err := parser.ParseDir(fs, path, nil, parser.ParseComments)
	if err != nil {
		return err
	}

	if len(pkgs) == 0 {
		return nil
	}

	title := func(s string) string {
		return strings.ToUpper(s[:1]) + s[1:]
	}

	for _, pkg := range pkgs {
		if strings.Contains(pkg.Name, "_test") {
			continue
		}
		if len(pkg.Files) == 0 {
			continue
		}

		enums := make(map[string][]string)

		output := filepath.Join(path, fmt.Sprintf("%s_enum_gen.go", pkg.Name))

		for _, file := range pkg.Files {
			m := processFile(file)
			for k, v := range m {
				enums[k] = v
			}
		}

		if len(enums) == 0 {
			continue
		}

		f := jen.NewFile(pkg.Name)

		f.HeaderComment("Code generated by enumerator. DO NOT EDIT.")

		for sourceName, values := range enums {
			name := title(strings.TrimSuffix(sourceName, "Enum"))

			errorMessage := fmt.Sprintf("invalid value for type '%s': '%%s'", name)

			f.Type().
				Id(name).
				Struct(jen.Id("v").Id(sourceName))

			f.Var().
				DefsFunc(func(g *jen.Group) {
					for _, v := range values {
						g.Id(title(v)).
							Op("=").
							Id(name).
							Values(jen.Id(v))
					}
				})

			f.Func().
				Params(
					jen.Id("r").Id(name),
				).
				Id("String").
				Params().
				String().
				Block(
					jen.Return(jen.Id("string").Call(jen.Id("r").Dot("v"))),
				)

			f.Func().
				Params(
					jen.Id("r").Id(name),
				).
				Id("MarshalText").
				Params().
				Params(
					jen.Id("[]byte"),
					jen.Id("error"),
				).
				Block(
					jen.Return(
						jen.Id("[]byte").Call(jen.Id("r").Dot("v")),
						jen.Nil(),
					),
				)

			f.Func().
				Params(
					jen.Id("r").Op("*").Id(name),
				).
				Id("UnmarshalText").
				Params(
					jen.Id("in").Id("[]byte"),
				).
				Params(
					jen.Id("error"),
				).
				Block(
					jen.List(
						jen.Id("s"),
						jen.Id("err"),
					).Op(":=").Id("New"+name).Call(jen.Id("string").Call(jen.Id("in"))),

					jen.If(jen.Id("err").Op("!=").Nil()).Block(
						jen.Return(jen.Id("err")),
					),

					jen.Id("*r").Op("=").Id("s"),

					jen.Return(
						jen.Nil(),
					),
				)

			f.Func().
				Params(
					jen.Id("r").Id(name),
				).
				Id("Value").
				Params().
				Params(
					jen.Qual("database/sql/driver", "Value"),
					jen.Id("error"),
				).
				Block(
					jen.Return(
						jen.Id("r").Dot("v"),
						jen.Nil(),
					),
				)

			f.Func().
				Params(
					jen.Id("r").Op("*").Id(name),
				).
				Id("Scan").
				Params(
					jen.Id("in").Any(),
				).
				Params(
					jen.Id("error"),
				).
				Block(
					jen.List(
						jen.Id("s"),
						jen.Id("err"),
					).Op(":=").Id("New"+name).Call(jen.Qual("fmt", "Sprint").Call(jen.Id("in"))),

					jen.If(jen.Id("err").Op("!=").Nil()).Block(
						jen.Return(jen.Id("err")),
					),

					jen.Id("*r").Op("=").Id("s"),

					jen.Return(
						jen.Nil(),
					),
				)

			f.Func().
				Id("New"+name).
				Params(jen.Id("in").Id("string")).
				Params(
					jen.Id(name),
					jen.Id("error"),
				).
				Block(
					jen.Switch(jen.Id("in")).BlockFunc(func(g *jen.Group) {
						for _, v := range values {
							g.Case(jen.Id("string").Call(jen.Id(v))).Block(
								jen.Return(jen.Id(title(v)), jen.Nil()),
							)
						}

						g.Default().Block(jen.Return(
							jen.Id(name).
								Values(),

							jen.Qual("fmt", "Errorf").Call(
								jen.Lit(errorMessage),
								jen.Id("in"),
							),
						))
					}),
				)
		}

		if err := f.Save(output); err != nil {
			return err
		}
	}

	return nil
}

func processFile(file *ast.File) map[string][]string {
	enumTypes := gatherEnumTypes(file)

	types := make(map[string][]string)

	for _, d := range file.Decls {
		decl, ok := d.(*ast.GenDecl)
		if !ok {
			continue
		}

		if decl.Tok != token.CONST {
			continue
		}

		if len(decl.Specs) < 2 {
			continue
		}

		for _, spec := range decl.Specs {
			v, ok := spec.(*ast.ValueSpec)
			if !ok {
				continue
			}

			name := v.Type.(*ast.Ident).Name

			_, ok = enumTypes[name]
			if !ok {
				continue
			}

			l := types[name]

			l = append(l, v.Names[0].Name)

			types[name] = l
		}
	}

	return types
}

func gatherEnumTypes(file *ast.File) map[string]*ast.TypeSpec {
	types := make(map[string]*ast.TypeSpec)

	for _, d := range file.Decls {
		decl, ok := d.(*ast.GenDecl)
		if !ok {
			continue
		}

		if decl.Tok != token.TYPE {
			continue
		}

		spec, ok := decl.Specs[0].(*ast.TypeSpec)
		if !ok {
			continue
		}

		_, ok = spec.Type.(*ast.Ident)
		if !ok {
			continue
		}

		if !strings.HasSuffix(spec.Name.Name, "Enum") {
			continue
		}

		types[spec.Name.Name] = spec
	}

	return types
}
